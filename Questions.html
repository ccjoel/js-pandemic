<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="robots" content="noindex, nofollow">
  <meta name="googlebot" content="noindex, nofollow">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="text/javascript" src="http://code.jquery.com/jquery-1.7.1.js"></script>

  <style type="text/css">
   p {
       padding-left: 15px;
   }
   #question {
       border: 1px solid gray;
   }
   div {
       padding: 15px;
       border: 1px solid blue;
   }
  </style>
  <title> by ICS</title>

  <script type='text/javascript'>//<![CDATA[
    $(function() {

        // ========================= Conventions ===============================

        /**
         * - Use NOTE for meta on solution, mostly over explains for interview purposes.
         *   Example: Declare with `const` if variable does not change, UPPERCASE_CONVENTION if real constant (eg PI)
         * - Use camelcase for fn and variable names
         * - Use snake_case for solution variations
         * - Use Startcase for original question fn names (eg Q1), which are "public" fns
         **/

        // =========================== Solutions ===============================

        /**
         * See https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
         **/
        function primes(start, end) {
            const n = end + 1;

            const sieve = new Array(n).fill(true)

            for (let x = 2; x <= Math.sqrt(n); x++) {
                if (sieve[x]) {
                    for (let y = Math.pow(x, 2); y <= n; y += x) {
                        sieve[y] = false;
                    }
                }
            }

            return sieve.reduce((acc, isPrime, index) => {
                return (isPrime && index >= start && index > 1) ?
                       [...acc, index] :
                       acc;
            }, []);

        }

        function Q1(number1, number2) {
            let returnValue = primes(number1, number2);
            return returnValue.join(' ');
        }

        /**
         * Given a positive integer, returns if it is a palindrome.
         **/
        function isPalindrome(num) {
            const asString = num.toString();

            const reversed = asString
                .split('')
                .reverse()
                .join('');

            return asString === reversed;
        }

        /**
         * Given a positive integer K of max 1,000,000 digits
         * return the next palindrome number, if it exists;
         * 1,000,000 digits is larger than javascript's maximum JS number.
         * Returns null if, given a valid input, cannot find the next palindrome within
         * javascript's integer constraints.
         **/
        function Q2(K) {
            if (!Number.isInteger(K)) {
                throw new TypeError(`Q2 expects an integer. Received "${K}" of type "${typeof K}".`);
            }
            if (K < 0 || K > Number.MAX_SAFE_INTEGER) {
                throw new RangeError(`Q2 expects a positive integer up to ${Number.MAX_SAFE_INTEGER}.`);
            }

            // Can still go over safest integer while searching
            for (let counter = K + 1; counter < Number.MAX_SAFE_INTEGER; counter++) {
                if (isPalindrome(counter)) {
                    return counter;
                }
            }

            return null;
        }

        /**
         * Scans a string for the length of the character repeating itself until
         * a different character is found.
         * That is,
         * Given 'a', and 'aaab', returns 3.
         * Given 'a', and 'abb', returns 1.
         * Given 'a', and 'b', returns 0.
         * @returns {number}
         **/
        function scanRepeated(character, str) {
            const re = new RegExp(`${character}+`);
            const result = str.match(re);

            return result ? result[0].length : 0; // can use lodash/get
        }

        // Compress lookahead, with partial regex
        // snake_case convention for variations of same fn
        function compress_scan(string1) {
            let accumulator = '';
            let index = 0;

            while (index < string1.length) {
                const currentChar = string1[index];
                const occurrences = scanRepeated(currentChar, string1.substring(index));
                const displayCount = occurrences === 1 ? '' : occurrences;

                accumulator += currentChar + displayCount;
                index += occurrences;
            }

            return accumulator;
        }

        /**
         * Given that lookbehind (store and compare to previous char) was more involved,
         * implement by compressing and looking ahead.
         **/
        function compress_lookahead(string1) {

            let accumulator = '';

            for (
                let index = 0,
                    repeatCounter = 0;

                index < string1.length;
                index++
            ) {
                repeatCounter++;
                const current = string1[index];
                const next = string1[index + 1];

                if (current !== next) {
                    const displayCount = repeatCounter === 1 ? '' : repeatCounter;
                    accumulator += current + displayCount;
                    repeatCounter = 0;
                }
            }

            return accumulator;
        }

        // NOTE Full regex solution, lone capture group is a character
        const compress_regex = string1 =>
            string1.replace(
                /(.)\1+/g,
                (fullMatch, character) => character + fullMatch.length
            );

        /**
         * Compresses a string.
         * eg: "bdddda" => "bd4a"
         **/
        function Q3(string1) {
            if (typeof string1 !== 'string') {
                throw new TypeError(`Q3: Expected argument for "string1" to be a string, received: ${string1}`);
            }
            return compress_lookahead(string1);
        }

        // ============================== Helpers =============================
        function appendNewLine(selector) {
            $(selector).append(document.createElement('br'));
        }
        function appendMultiple(selector, arrResults) {
            const element = $(selector);             // NOTE Find element on dom once
            // NOTE Side effects only
            arrResults.forEach(result => {
                element.append(result || '{empty}'); // NOTE {empty} used to account result on page.
                appendNewLine(selector);
            });
        }

        // ===================== Append results to questions ===================

        appendMultiple('#results1', [
            Q1(1, 10),
            Q1(3, 23)
        ]);

        const q2Selector = '#results2';

        $(q2Selector).append(Q2(907008));

        appendNewLine(q2Selector);

        // Example of Q2 that fails some validation
        let q2error = null;
        try {
            q2error = Q2('a');
        } catch(e) {
            // We will always fallback to append regardless of error type
            q2error = `Caught expected error: ${e.message}`;
        }
        $(q2Selector).append(q2error);

        const q3Selector = '#results3';
        appendMultiple(q3Selector, [
            Q3('aaabaaaaccaaaaba'),
            Q3('a'),
            Q3('1'),
            Q3(''),
            compress_regex('aaabaaaaccaaaaba'),
            compress_lookahead('aaaa'),
            compress_lookahead('c'),
            compress_lookahead('caaazwwbb'),
            compress_regex('abcd'),
            compress_scan('aabcb11')
        ]);

        // Example of Q2 that fails some validation
        let q3error = null;
        try {
            q3error = Q3(4);
        } catch(e) {
            q3error = `Caught expected error: ${e.message}.`;
        }
        $(q3Selector).append(q3error);

    });//]]>

    </script>

</head>

<body>
  <!--don't edit this file-->
<div id=question>
  <span style="font-weight:bold">Question 1:</span> Generate all prime numbers between two given numbers.
  The two numbers are parameters that can be passed into the function. A prime number is one that is only
  divisible by 1 and itself. Output the results into the results element below.
  <p>
    Example:
    <br/> Primes between 1 and 10
    <br/> Output:
    <br/> 2
    <br/> 3
    <br/> 5
    <br/> 7
    <br/>
  </p>
</div>
<br/>
<p>Your Results:</p>
<div id="results1"></div>
<br/>
<div id=question>
<span style="font-weight:bold">Question 2:</span> A positive integer is called a palindrome if its
representation in the decimal system is the same when read from left to right and from right to left.
For a given positive integer K of not more than 1000000 digits, write the value of the smallest
palindrome larger than K to output. Numbers are always displayed without leading zeros.
  <P>
    Example:
    <br/> Number Given: 808
    <br/> Output: 818
    <br/> Number Given: 2133
    <br/> Output: 2222
    <br/>
  </P>
</div>
<br/>
<p>Your Results:</p>
<div id="results2"></div>
<br/>
<div id="question">
  <span style="font-weight:bold">Question 3:</span> Write a simple string compression algorithm.
  If a character [ch] occurs n>1 times in a row, then it will be represented by [ch][n].
  <P>
    Example:
    <br/> String Given: aaaa
    <br/> Output: a4
    <br/>
    <br/> String Given: aaabaaaaccaaaaba
    <br/> Output: a3ba4c2a4ba
    <br/>
    <br/> String Given: abcd
    <br/> Output: abcd
    <br/>
  </P>
</div>
<br/>
<p>Your Results:</p>
<div id="results3"></div>
</body>

</html>
